--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/WorkoutPage.css ---

.camera-container {
  position: relative; /* Ensure overlays position correctly */
  width: min(90vw, 1200px); /* Responsive width, max 1200px */
  height: min(56.25vw, 675px); /* Maintain 16:9 aspect ratio (56.25% of width = 9/16) */
  max-height: 80vh; /* Keep as you have it, or adjust if needed */
  margin: 10px auto;
  border: 2px solid #333;
  border-radius: 8px;
  overflow: hidden;
  background-color: #000;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  animation: fadeIn 0.5s ease-in;
}

.camera-container video,
.camera-container canvas {
  width: 100% !important;
  height: 100% !important;
  object-fit: cover; /* Ensures the video/canvas covers the container */
  position: absolute; /* Allows overlays to sit on top */
  top: 0;
  left: 0;
}

@keyframes pulse {
  0% {
    transform: translate(-50%, -50%) scale(1); /* Starting size */
  }
  50% {
    transform: translate(-50%, -50%) scale(1.1); /* Slightly larger */
  }
  100% {
    transform: translate(-50%, -50%) scale(1); /* Back to starting size */
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
.overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

/* Add to WorkoutPage.css if you prefer to externalize the style */
.stop-test-button {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 15;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0;
  font-size: 1.2rem;
  font-weight: bold;
  line-height: 1;
  background: rgba(255, 0, 0, 0.7); /* Red background for stop button */
  color: white;
  border: none;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/CameraPlaceholder.tsx ---

import React from "react";
import { Exercise } from "../utils/poseUtils"; // Still import Exercise interface for prop typing

interface CameraPlaceholderProps {
  show: boolean;
  onStart: () => void;
  exercise: Exercise | null; // Keep for consistency of prop passing, even if not displayed
  cameraError: string | null;
}

const CameraPlaceholder: React.FC<CameraPlaceholderProps> = ({
  show,
  onStart,
  exercise, // Keep exercise prop, just don't display it directly here
  cameraError,
}) => {
  if (!show) return null;

  return (
    <div
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        backgroundColor: "#1a1a1a",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 5,
        color: "#fff",
        padding: "20px",
        textAlign: "center",
      }}
    >
      <div style={{ textAlign: "center", color: "#fff" }}>
        <h3>Ready to start your workout?</h3>
        <p>Press Start to activate camera and begin.</p>
        {cameraError && (
          <p style={{ color: "red", marginTop: "10px" }}>
            <strong>Camera Error:</strong> {cameraError}
          </p>
        )}
        {/* Removed redundant exercise name and description here.
            This information is already displayed in the main header
            when workoutPhase is 'idle'.
        <div style={{ marginTop: "20px" }}>
            <strong>{exercise?.name}</strong>
            <p>{exercise?.description}</p>
        </div>
        */}
      </div>
    </div>
  );
};

export default CameraPlaceholder;

--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/CountdownOverlay.tsx ---

import React, { useEffect } from "react";

interface CountdownOverlayProps {
  value: number;
  onComplete: () => void;
  show: boolean;
}

const CountdownOverlay: React.FC<CountdownOverlayProps> = ({
  value,
  onComplete,
  show,
}) => {
  // Removed the useEffect that decremented value here.
  // The value is now controlled by the parent (WorkoutPage).

  // The onComplete logic still belongs here, triggered when value becomes 0 or less.
  useEffect(() => {
    if (!show) return;
    if (value <= 0) {
      onComplete();
    }
  }, [value, show, onComplete]);

  if (!show) return null;

  return (
    <div
      style={{
        position: "absolute",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        fontSize: "8rem", // Bigger font size as per guide
        fontWeight: "bold",
        color: "#fff",
        textShadow: "2px 2px 4px rgba(0,0,0,0.8)",
        zIndex: 10,
        animation: "pulse 1s ease-in-out infinite", // Apply pulse animation
      }}
    >
      {value > 0 ? value : "GO!"}
    </div>
  );
};

export default CountdownOverlay;

--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/ExerciseInfoOverlay.tsx ---

import React from "react";

interface ExerciseInfoOverlayProps {
  reps: number;
  feedback: string;
  show: boolean;
}

const ExerciseInfoOverlay: React.FC<ExerciseInfoOverlayProps> = ({
  reps,
  feedback,
  show,
}) => {
  if (!show) return null;

  return (
    <div
      style={{
        position: "absolute",
        bottom: "20px",
        left: "20px",
        right: "20px",
        backgroundColor: "rgba(0,0,0,0.8)",
        color: "#fff",
        padding: "15px",
        borderRadius: "10px",
        zIndex: 10,
      }}
    >
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <div>
          <h4 style={{ margin: 0, color: "#28a745" }}>Reps: {reps}</h4>
        </div>
        <div style={{ textAlign: "right" }}>
          <p style={{ margin: 0, fontSize: "0.9rem" }}>{feedback}</p>
        </div>
      </div>
    </div>
  );
};

export default ExerciseInfoOverlay;

--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/TimerOverlay.tsx ---

import React, { useState, useEffect, useRef } from 'react';

interface TimerOverlayProps {
  isRunning: boolean;
  seconds: number; // This will now be the initial value for countdown
  show: boolean;
  onTimeUpdate?: (seconds: number) => void;
  isCountdown?: boolean; // NEW PROP: true if it's a countdown, false/undefined if count up
}

const TimerOverlay: React.FC<TimerOverlayProps> = ({ isRunning, seconds: initialSeconds, show, onTimeUpdate, isCountdown = false }) => {
  const [currentSeconds, setCurrentSeconds] = useState(initialSeconds);
  const intervalIdRef = useRef<number | null>(null);

  // Sync internal state with prop for initial value or resets from parent
  useEffect(() => {
    setCurrentSeconds(initialSeconds);
  }, [initialSeconds]);

  useEffect(() => {
    const cleanupInterval = () => {
      if (intervalIdRef.current !== null) {
        clearInterval(intervalIdRef.current);
        intervalIdRef.current = null;
      }
    };

    if (isRunning) {
      cleanupInterval(); // Clear any existing interval
      intervalIdRef.current = window.setInterval(() => {
        setCurrentSeconds(prevSeconds => {
          if (isCountdown) {
            // Counting down
            if (prevSeconds <= 0) {
              cleanupInterval(); // Stop at 0
              return 0;
            }
            return prevSeconds - 1;
          } else {
            // Counting up
            return prevSeconds + 1;
          }
        });
      }, 1000);
    } else {
      cleanupInterval(); // Stop the interval if not running
    }

    return cleanupInterval; // Cleanup on unmount or isRunning change
  }, [isRunning, isCountdown]);

  // Communicate internal seconds back to parent
  useEffect(() => {
    if (onTimeUpdate) {
      onTimeUpdate(currentSeconds);
    }
  }, [currentSeconds, onTimeUpdate]);

  const formatTime = (totalSeconds: number): string => {
    const minutes = Math.floor(totalSeconds / 60);
    const remainingSeconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  if (!show) {
    return null;
  }

  return (
    <div
      style={{
        position: "absolute",
        top: "20px",
        right: "20px",
        backgroundColor: "rgba(0,0,0,0.7)",
        color: "#fff",
        padding: "10px 20px",
        borderRadius: "25px",
        fontSize: "1.5rem",
        fontWeight: "bold",
        zIndex: 10,
        fontFamily: "monospace",
      }}
    >
      {formatTime(currentSeconds)}
    </div>
  );
};

export default TimerOverlay;


--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/WorkoutPage.tsx ---

import React, {
  useRef,
  useEffect,
  useState,
  useCallback,
  useMemo,
} from "react";
import { useParams } from "react-router-dom";
import { drawConnectors, drawLandmarks } from "@mediapipe/drawing_utils";
import { Pose, POSE_CONNECTIONS, Results } from "@mediapipe/pose";
import {
  Landmark,
  calculateAngle,
  RepCounter,
  Exercise,
} from "../utils/poseUtils";
import api from "../utils/api";

// Import new components
import CountdownOverlay from "./CountdownOverlay";
import CameraPlaceholder from "./CameraPlaceholder";
import WorkoutReport from "./WorkoutReport";
import TimerOverlay from "./TimerOverlay";
import ExerciseInfoOverlay from "./ExerciseInfoOverlay";

// Import the CSS file
import "../WorkoutPage.css";

interface WorkoutReportData {
  exerciseName: string;
  duration: number;
  totalReps: number;
  accuracy: number;
  completedAt: Date;
}

const WorkoutPage: React.FC = () => {
  const { id: exerciseId } = useParams<{ id: string }>();
  const videoElementRef = useRef<HTMLVideoElement>(null);
  const canvasElementRef = useRef<HTMLCanvasElement>(null);
  const contextRef = useRef<CanvasRenderingContext2D | null>(null);

  const [isVideoElementReady, setIsVideoElementReady] = useState(false);
  const [isCanvasElementReady, setIsCanvasElementReady] = useState(false);

  const repCounterRef = useRef<RepCounter | null>(null);
  const currentRepsRef = useRef(0);
  const [exercise, setExercise] = useState<Exercise | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [cameraError, setCameraError] = useState<string | null>(null);

  // New state variables for workout flow and UI
  const [workoutPhase, setWorkoutPhase] = useState<
    "idle" |
    "countdown" | "active" | "completed"
  >("idle");
  const [showCountdown, setShowCountdown] = useState(false);
  const [countdownValue, setCountdownValue] = useState(3);
  const [cameraActive, setCameraActive] = useState(false);
  const [showPlaceholder, setShowPlaceholder] = useState(true);
  const [showReport, setShowReport] = useState(false);
  const [workoutReport, setWorkoutReport] = useState<WorkoutReportData | null>(
    null
  );

  const [isWorkoutRunning, setIsWorkoutRunning] = useState(false);
  const [countdownWorkoutTime, setCountdownWorkoutTime] = useState(60); // State for 60-second countdown
  const [workoutDuration, setWorkoutDuration] = useState(0);
  const [displayReps, setDisplayReps] = useState(0);
  const [displayFeedback, setDisplayFeedback] = useState(
    "Stand still to begin."
  );

  // NEW STATE: For the early exit warning message
  const [showWarning, setShowWarning] = useState(false);
  const [warningMessage, setWarningMessage] = useState('');

  const landmarkNameToIndex = useMemo(() => {
    const map: { [key: string]: number } = {
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
    };
    return map;
  }, []);

  // --- onResults Callback ---
  const onResults = useCallback(
    (results: Results) => {
      // Only process results if workout is active
      if (workoutPhase !== "active" || !exercise) {
        // Clear canvas if not active but MediaPipe might still be sending frames
        const canvasCtx = contextRef.current;
        const canvas = canvasElementRef.current;
        if (canvasCtx && canvas) {
          canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }

      const canvasCtx = contextRef.current;
      const canvas = canvasElementRef.current;
      const video = videoElementRef.current;

      if (!canvasCtx || !canvas || !video || !exercise) return;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

      const imageWidth = results.image.width;
      const imageHeight = results.image.height;

      if (canvas.width !== imageWidth || canvas.height !== imageHeight) {
        canvas.width = imageWidth;
        canvas.height = imageHeight;
        console.log(`Canvas resized to match image: ${imageWidth}x${imageHeight}`);
      }
      
      // It's crucial to draw the video image onto the canvas here
      canvasCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      if (results.poseLandmarks) {
        const mpLandmarks = results.poseLandmarks;
        const landmarksMap: { [key: string]: Landmark } = {};

        if (mpLandmarks[11])
          landmarksMap["left_shoulder"] = mpLandmarks[11] as Landmark;
        if (mpLandmarks[12])
          landmarksMap["right_shoulder"] = mpLandmarks[12] as Landmark;
        if (mpLandmarks[13])
          landmarksMap["left_elbow"] = mpLandmarks[13] as Landmark;
        if (mpLandmarks[14])
          landmarksMap["right_elbow"] = mpLandmarks[14] as Landmark;
        if (mpLandmarks[15])
          landmarksMap["left_wrist"] = mpLandmarks[15] as Landmark;
        if (mpLandmarks[16])
          landmarksMap["right_wrist"] = mpLandmarks[16] as Landmark;
        if (mpLandmarks[23])
          landmarksMap["left_hip"] = mpLandmarks[23] as Landmark;
        if (mpLandmarks[24])
          landmarksMap["right_hip"] = mpLandmarks[24] as Landmark;
        if (mpLandmarks[25])
          landmarksMap["left_knee"] = mpLandmarks[25] as Landmark;
        if (mpLandmarks[26])
          landmarksMap["right_knee"] = mpLandmarks[26] as Landmark;
        if (mpLandmarks[27])
          landmarksMap["left_ankle"] = mpLandmarks[27] as Landmark;
        if (mpLandmarks[28])
          landmarksMap["right_ankle"] = mpLandmarks[28] as Landmark;

        let overallFormCorrect = true;
        let currentFrameFeedback = "";
        const jointsToHighlightRed: number[] = [];
        const connectionsToHighlightRed: [number, number][] = [];
        if (repCounterRef.current && isWorkoutRunning) {
          exercise.checkpoints.forEach((checkpoint) => {
            const p1 = landmarksMap[checkpoint.keypoint1];
            const p2 = landmarksMap[checkpoint.keypoint2];
            const p3 = landmarksMap[checkpoint.keypoint3];

            if (
              !p1 ||
              !p2 ||
              !p3 ||
              (p1.visibility && p1.visibility < 0.8) ||
              (p2.visibility && p2.visibility < 0.8) ||
              (p3.visibility && p3.visibility < 0.8)
            ) {
              overallFormCorrect = false;
              if (currentFrameFeedback === "") {
                currentFrameFeedback = "Ensure full body is visible!";
              }
              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);
              return;
            }

            // Calculate the angle between the three points
            if (!p1 || !p2 || !p3) return;
            const currentAngle = calculateAngle(p1, p2, p3);
            const isInRange =
              Math.abs(currentAngle - checkpoint.targetAngle) <=
              checkpoint.tolerance;
            if (!isInRange) {
              overallFormCorrect = false;
              if (currentAngle < checkpoint.targetAngle) {
                currentFrameFeedback = `Too shallow at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              } else {
                currentFrameFeedback = `Too deep/overextended at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              }

              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (
                p1Idx !== undefined &&
                p2Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p1Idx && c[1] === p2Idx
                )
              ) {
                connectionsToHighlightRed.push([p1Idx, p2Idx]);
              }
              if (
                p2Idx !== undefined &&
                p3Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p2Idx && c[1] === p3Idx
                )
              ) {
                connectionsToHighlightRed.push([p2Idx, p3Idx]);
              }
              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);
            }
          });
          // If form is correct, update reps and feedback
          const newReps = repCounterRef.current.detectRep(landmarksMap);
          if (newReps !== currentRepsRef.current) {
            currentRepsRef.current = newReps;
            setDisplayReps(newReps);
            setDisplayFeedback("Great Rep!");
          } else if (overallFormCorrect && currentFrameFeedback === "") {
            setDisplayFeedback("Good form!");
          } else if (currentFrameFeedback !== "") {
            setDisplayFeedback(currentFrameFeedback);
          } else {
            setDisplayFeedback("Adjust your position.");
          }
        }

        // --- Drawing Logic ---
        drawConnectors(canvasCtx, mpLandmarks, POSE_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 4,
        });
        drawLandmarks(canvasCtx, mpLandmarks, {
          color: "#00FF00",
          lineWidth: 2,
        });
        connectionsToHighlightRed.forEach(([p1Idx, p2Idx]) => {
          drawConnectors(canvasCtx, mpLandmarks, [[p1Idx, p2Idx]], {
            color: "#FF0000",
            lineWidth: 4,
          });
        });
        const redLandmarksToDraw = mpLandmarks.filter((_, idx) =>
          jointsToHighlightRed.includes(idx)
        );
        if (redLandmarksToDraw.length > 0) {
          drawLandmarks(canvasCtx, redLandmarksToDraw, {
            color: "#FF0000",
            lineWidth: 2,
          });
        }
      }
      canvasCtx.restore();
    },
    [workoutPhase, exercise, landmarkNameToIndex, isWorkoutRunning]
  );

  // --- useEffect to fetch Exercise details ---
  useEffect(() => {
    const fetchExercise = async () => {
      try {
        const res = await api.get<Exercise>(`/exercises/${exerciseId}`);
        setExercise(res.data);
        repCounterRef.current = new RepCounter(res.data.checkpoints);
        setLoading(false);
      } catch (err: any) {
        console.error("Error fetching exercise:", err);
        setError(
          err.response?.data?.message || "Failed to load exercise details"
        );
        setLoading(false);
      }
    };

    if (exerciseId) {
      fetchExercise();
    } else {
      setError("No exercise ID provided.");
      setLoading(false);
    }
  }, [exerciseId]);

  // --- Unified useEffect for MediaPipe, Camera Setup, and Canvas Context ---
  useEffect(() => {
    console.log("Unified MediaPipe & Camera Setup useEffect: Running.");

    const videoElement = videoElementRef.current;
    const canvasElement = canvasElementRef.current;
    let ctx: CanvasRenderingContext2D | null = null;

    if (
      !cameraActive ||
      !isVideoElementReady ||
      !isCanvasElementReady ||
      !videoElement ||
      !canvasElement
    ) {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: Waiting for cameraActive or refs.",
        {
          cameraActive,
          isVideoElementReady,
          isCanvasElementReady,
          video: videoElement,
          canvas: canvasElement,
          context: ctx,
        }
      );
      return () => {
        console.log(
          "Unified MediaPipe & Camera Setup useEffect: No setup to clean up (refs not ready on initial mount or camera not active)."
        );
      };
    }

    console.log(
      "Unified MediaPipe & Camera Setup useEffect: All refs and state confirm mount and camera active. Proceeding with setup."
    );
    ctx = canvasElement.getContext("2d");
    if (ctx) {
      contextRef.current = ctx;
      console.log("Canvas context successfully initialized.");
    } else {
      console.error("Failed to get 2D context from canvas. Cannot proceed.");
      setError("Your browser does not support canvas 2D rendering.");
      setCameraError("Your browser does not support canvas 2D rendering.");
      return;
    }

    canvasElement.width = videoElement.videoWidth || 640;
    canvasElement.height = videoElement.videoHeight || 480;
    console.log("Canvas initial dimensions set.");

    console.log("Initializing Pose model.");
    let pose: Pose | null = new Pose({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      },
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      smoothSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });
    pose.onResults(onResults);
    console.log("Pose model initialized and onResults bound.");

    console.log("Attempting to get media stream and setup custom frame loop.");
    let frameId: number | null = null;
    navigator.mediaDevices
      .getUserMedia({ video: { width: 1280, height: 720 } })
      .then((stream) => {
        videoElement.srcObject = stream;
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          const currentPose = pose;
          const currentVideo = videoElement;

          const sendFrameToPose = async () => {
            if (currentVideo.readyState === 4 && currentPose) {
              try {
                await currentPose.send({ image: currentVideo });
              } catch (e: any) {
                console.warn(
                  "Error sending image to pose model, likely cleanup in progress:",
                  e.message
                );
                if (e.message.includes("deleted object") && frameId !== null) {
                  cancelAnimationFrame(frameId);
                  frameId = null;
                  console.log(
                    "Stopped sending frames due to deleted pose model."
                  );
                }
              }
            }
            if (frameId !== null) {
              frameId = requestAnimationFrame(sendFrameToPose);
            }
          };
          frameId = requestAnimationFrame(sendFrameToPose);
          console.log("Camera stream started and frame loop initiated.");
        };
        console.log("getUserMedia resolved: Video stream acquired.");
      })
      .catch((err) => {
        console.error("Failed to get video stream:", err);
        let errorMessage = "Camera access failed.";
        if (err.name === "NotAllowedError") {
          errorMessage +=
            " Please allow camera permissions and refresh the page.";
        } else if (err.name === "NotFoundError") {
          errorMessage +=
            " No camera found. Please connect a camera and try again.";
        } else {
          errorMessage += " Please check your camera and try again.";
        }
        setCameraError(errorMessage);
        setError(errorMessage);
      });
    return () => {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: Cleanup running."
      );
      if (frameId !== null) {
        cancelAnimationFrame(frameId);
        frameId = null;
        console.log("Cleanup: Animation frame loop canceled.");
      }

      if (videoElement.srcObject) {
        const stream = videoElement.srcObject as MediaStream;
        stream.getTracks().forEach((track) => track.stop());
        videoElement.srcObject = null;
        console.log("Cleanup: Video stream tracks stopped.");
      }
      if (pose) {
        console.log("Cleanup: Closing Pose model.");
        pose.close();
      }

      if (ctx && canvasElement) {
        console.log("Cleanup: Clearing canvas.");
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      }
    };
  }, [onResults, isVideoElementReady, isCanvasElementReady, cameraActive]);

  // Modified stopWorkout to accept a parameter for early exit
  const stopWorkout = useCallback((isEarlyExit: boolean) => {
    setIsWorkoutRunning(false);
    setWorkoutPhase("completed");
    setCameraActive(false);

    if (isEarlyExit) {
      // Scenario: User manually ended workout (pressed 'X')
      setWarningMessage("Workout ended early! Your fitness test results will not be saved due to incomplete duration.");
      setShowWarning(true);
      // Ensure workout report is NOT shown for early exit
      setShowReport(false);
      setWorkoutReport(null);
    } else {
      // Scenario: Workout completed naturally (time ended)
      const report: WorkoutReportData = {
        exerciseName: exercise?.name || "Unknown",
        duration: workoutDuration,
        totalReps: displayReps,
        accuracy: 85, // Placeholder, will be calculated based on form feedback logic
        completedAt: new Date(),
      };
      setWorkoutReport(report);
      setShowReport(true);
      // Ensure warning is NOT shown for natural completion
      setShowWarning(false);
      setWarningMessage('');
    }

    // Clear video stream (common to both scenarios)
    const videoElement = videoElementRef.current;
    if (videoElement && videoElement.srcObject) {
      const stream = videoElement.srcObject as MediaStream;
      stream.getTracks().forEach((track) => track.stop());
      videoElement.srcObject = null;
    }
  }, [exercise, workoutDuration, displayReps, setIsWorkoutRunning, setWorkoutPhase, setCameraActive, setWarningMessage, setShowWarning, setWorkoutReport, setShowReport]);

  const handleCountdownComplete = useCallback(() => {
    setShowCountdown(false);
    setWorkoutPhase("active");
    setIsWorkoutRunning(true);
    currentRepsRef.current = 0;
    setDisplayReps(0);
    setDisplayFeedback("Workout started! Do your first rep.");
    if (repCounterRef.current) {
      repCounterRef.current.reset();
    }
    setCountdownWorkoutTime(60); // Reset countdown for the workout itself
  }, [setIsWorkoutRunning, setWorkoutPhase, setDisplayReps, setDisplayFeedback, setCountdownWorkoutTime]);

  // FIX: Ensure handleTimeUpdate only updates if the workout is active
  const handleTimeUpdate = useCallback(
    (seconds: number) => {
      // Only update time-related states if the workout is still in the 'active' phase.
      // This prevents further updates once stopWorkout has been called and changed the phase.
      if (workoutPhase === "active") {
        setCountdownWorkoutTime(seconds);
        setWorkoutDuration(seconds);

        if (seconds <= 0) {
          // Pass 'false' because it's a natural completion by time
          stopWorkout(false);
        }
      }
    },
    [workoutPhase, setWorkoutDuration, stopWorkout, setCountdownWorkoutTime]
  );

  useEffect(() => {
    let countdownInterval: number | undefined;
    if (workoutPhase === "countdown" && showCountdown) {
      countdownInterval = window.setInterval(() => {
        setCountdownValue((prev) => {
          if (prev <= 1) {
            clearInterval(countdownInterval);
            handleCountdownComplete();
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }
    };
  }, [workoutPhase, showCountdown, handleCountdownComplete]);

  const handleStartClick = () => {
    if (workoutPhase === "idle") {
      setCameraActive(true);
      setShowPlaceholder(false);
      setTimeout(() => {
        startWorkout();
      }, 500);
    }
  };

  const startWorkout = () => {
    setWorkoutPhase("countdown");
    setShowCountdown(true);
    setCountdownValue(3);
  };

  if (loading)
    return (
      <div className="container mt-5">
        <p>Loading exercise...</p>
      </div>
    );
  if (error)
    return (
      <div className="container mt-5">
        <p className="text-danger">Error: {error}</p>
      </div>
    );
  if (!exercise)
    return (
      <div className="container mt-5">
        <p>Exercise not found.</p>
      </div>
    );
  return (
    <div className="container-fluid" style={{ padding: 0 }}>
      {/* Header-only show when not in active workout */}
      {workoutPhase === "idle" && (
        <div style={{ padding: "10px", textAlign: "left" }}>
          <h1>{exercise.name}</h1>
          <p>{exercise.description}</p>
          <p>
            <strong>Target Muscles:</strong> {exercise.targetMuscles.join(", ")}
          </p>
          <p>
            <strong>Difficulty:</strong> {exercise.difficulty}
          </p>
        </div>
      )}

      {/* Control Buttons (removed the Finish Workout button from here) */}
      <div style={{ textAlign: "center", padding: "10px" }}>
        {workoutPhase === "idle" && (
          <button
            className="btn btn-success btn-lg"
            onClick={handleStartClick}
            style={{ minWidth: "200px" }}
          >
            Start Workout
          </button>
        )}
      </div>

      {/* Main Camera Area */}
      <div className="camera-container">
        {/* 'X' Overlay Button (New) */}
        {workoutPhase === "active" && (
          <button
            onClick={() => stopWorkout(true)} // Pass true for early exit
            style={{
              position: "absolute",
              top: "15px",
              left: "15px",
              backgroundColor: "rgba(255, 0, 0, 0.7)",
              color: "#fff",
              border: "none",
              borderRadius: "50%",
              width: "50px",
              height: "50px",
              fontSize: "1.8rem",
              fontWeight: "bold",
              cursor: "pointer",
              zIndex: 20, // Ensure it's above other overlays if needed
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              boxShadow: '0 2px 5px rgba(0,0,0,0.3)'
            }}
          >
            &#x2715; {/* Unicode 'X' character */}
          </button>
        )}

        {/* Camera Placeholder */}
        <CameraPlaceholder
          show={showPlaceholder}
          onStart={handleStartClick}
          exercise={exercise}
          cameraError={cameraError}
        />

        {/* Video and Canvas */}
        <video
          ref={(el) => {
            videoElementRef.current = el;
            if (el) setIsVideoElementReady(true);
            else setIsVideoElementReady(false);
          }}
          autoPlay
          playsInline
          muted
          style={{ display: cameraActive ? "block" : "none" }}
        ></video>
        <canvas
          ref={(el) => {
            canvasElementRef.current = el;
            if (el) setIsCanvasElementReady(true);
            else setIsCanvasElementReady(false);
          }}
          style={{ display: cameraActive ? "block" : "none" }}
        ></canvas>

        {/* Overlays */}
        <CountdownOverlay
          value={countdownValue}
          onComplete={handleCountdownComplete}
          show={showCountdown}
        />
        <TimerOverlay
          isRunning={isWorkoutRunning}
          seconds={countdownWorkoutTime}
          show={workoutPhase === "active"}
          onTimeUpdate={handleTimeUpdate}
          isCountdown={true}
        />
        <ExerciseInfoOverlay
          reps={displayReps}
          feedback={displayFeedback}
          show={workoutPhase === "active"}
        />
      </div>

      {/* NEW: Warning Message Overlay */}
      {showWarning && (
        <div
          style={{
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            backgroundColor: "rgba(255, 0, 0, 0.8)",
            color: "#fff",
            padding: "30px",
            borderRadius: "15px",
            fontSize: "1.8rem",
            fontWeight: "bold",
            textAlign: "center",
            zIndex: 100, // Make sure it's on top
            maxWidth: "80%",
            boxShadow: "0 0 20px rgba(0,0,0,0.5)"
          }}
        >
          <p>{warningMessage}</p>
          <button
            className="btn btn-light mt-3"
            onClick={() => {
              setShowWarning(false);
              // Reset workout page to idle state
              setWorkoutPhase("idle");
              setShowPlaceholder(true);
              setCameraActive(false);
              setWorkoutReport(null); // Clear any old report data
              setDisplayReps(0);
              setDisplayFeedback("Stand still to begin.");
              setWorkoutDuration(0);
              setCountdownWorkoutTime(60);
            }}
          >
            OK
          </button>
        </div>
      )}

      {/* Workout Report Modal (only shows if 'showReport' is true) */}
      <WorkoutReport
        report={workoutReport}
        onClose={() => {
          setShowReport(false);
          setWorkoutPhase("idle");
          setShowPlaceholder(true);
          setCameraActive(false);
          setWorkoutReport(null);
          setDisplayReps(0);
          setDisplayFeedback("Stand still to begin.");
          setWorkoutDuration(0);
          setCountdownWorkoutTime(60);
        }}
        show={showReport}
      />
    </div>
  );
};

export default WorkoutPage;

--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/WorkoutReport.tsx ---

import React from "react";

interface WorkoutReportData {
  exerciseName: string;
  duration: number; // Still part of the data, but won't be displayed
  totalReps: number;
  accuracy: number;
  completedAt: Date;
}

interface WorkoutReportProps {
  report: WorkoutReportData | null;
  onClose: () => void;
  show: boolean;
}

const WorkoutReport: React.FC<WorkoutReportProps> = ({
  report,
  onClose,
  show,
}) => {
  if (!show || !report) return null;

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        backgroundColor: "rgba(0,0,0,0.8)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 20,
      }}
    >
      <div
        style={{
          backgroundColor: "#fff",
          padding: "40px",
          borderRadius: "12px",
          textAlign: "center",
          maxWidth: "500px",
          width: "90%",
        }}
      >
        <h2 style={{ color: "#28a745", marginBottom: "30px" }}>
          Workout Complete!
        </h2>
        <div style={{ marginBottom: "30px" }}>
          <h3>{report.exerciseName}</h3>
          <div
            style={{
              display: "grid",
              // Changed from "1fr 1fr" to "1fr" to have a single column
              gridTemplateColumns: "1fr",
              gap: "20px",
              marginTop: "20px",
            }}
          >
            {/* Removed the Duration display section */}
            {/*
            <div>
              <h4 style={{ color: "#007bff" }}>Duration</h4>
              <p style={{ fontSize: "1.5rem", fontWeight: "bold" }}>
                {formatTime(report.duration)}
              </p>
            </div>
            */}
            <div>
              <h4 style={{ color: "#007bff" }}>Reps Completed</h4>
              <p style={{ fontSize: "1.5rem", fontWeight: "bold" }}>
                {report.totalReps}
              </p>
            </div>
          </div>
        </div>
        <button
          onClick={onClose}
          style={{
            backgroundColor: "#007bff",
            color: "#fff",
            border: "none",
            padding: "12px 30px",
            borderRadius: "6px",
            fontSize: "1.1rem",
            cursor: "pointer",
            marginRight: "10px",
          }}
        >
          Start New Workout
        </button>
        <button
          onClick={() => window.history.back()}
          style={{
            backgroundColor: "#6c757d",
            color: "#fff",
            border: "none",
            padding: "12px 30px",
            borderRadius: "6px",
            fontSize: "1.1rem",
            cursor: "pointer",
          }}
        >
          Back to Exercises
        </button>
      </div>
    </div>
  );
};

export default WorkoutReport;


--- /Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/utils/poseUtils.ts ---

// Define a type for MediaPipe Landmark points
export interface Landmark {
  x: number;
  y: number;
  z: number;
  visibility?: number;
}

/**
 * Calculates the angle (in degrees) between three 2D points.
 * Point2 is the vertex of the angle.
 */
export function calculateAngle(
  point1: Landmark,
  point2: Landmark,
  point3: Landmark
): number {
  // Vectors from point2 to point1 and point2 to point3
  const vector1 = [point1.x - point2.x, point1.y - point2.y];
  const vector2 = [point3.x - point2.x, point3.y - point2.y];

  // Calculate dot product
  const dotProduct = vector1[0] * vector2[0] + vector1[1] * vector2[1];

  // Calculate magnitudes
  const magnitude1 = Math.sqrt(vector1[0] ** 2 + vector1[1] ** 2);
  const magnitude2 = Math.sqrt(vector2[0] ** 2 + vector2[1] ** 2);

  // Avoid division by zero
  if (magnitude1 === 0 || magnitude2 === 0) {
    return 0; // Or handle as an error/invalid case
  }

  // Calculate angle in radians using arccosine
  // Clamp the argument to acos to prevent NaN due to floating point inaccuracies
  const cosAngle = dotProduct / (magnitude1 * magnitude2);
  const angleRad = Math.acos(Math.min(1, Math.max(-1, cosAngle)));

  // Convert to degrees
  const angleDeg = angleRad * (180 / Math.PI);

  return angleDeg;
}

// Interface for an exercise checkpoint (as defined in your backend Exercise model)
export interface ExerciseCheckpoint {
  keypoint1: string;
  keypoint2: string;
  keypoint3: string;
  targetAngle: number;
  tolerance: number;
  phase: "up" | "down";
}

// NEW: Interface for Exercise (consistent with your backend model)
export interface Exercise {
  _id: string;
  name: string;
  description: string;
  targetMuscles: string[];
  checkpoints: ExerciseCheckpoint[];
  instructions: string[];
  difficulty: string;
}

// Class to manage rep detection state for a single exercise
export class RepCounter {
  private inDownPhase: boolean = false;
  private inUpPhase: boolean = false;
  private repCount: number = 0;
  private currentCheckpoints: ExerciseCheckpoint[] = [];

  constructor(checkpoints: ExerciseCheckpoint[]) {
    this.currentCheckpoints = checkpoints;
  }

  public reset() {
    this.inDownPhase = false;
    this.inUpPhase = false;
    this.repCount = 0;
  }

  public getRepCount(): number {
    return this.repCount;
  }

  /**
   * Processes a new frame's pose data to detect reps.
   * Call this for each relevant checkpoint.
   * @returns The current rep count after processing this frame.
   */
  public detectRep(keypoints: { [key: string]: Landmark }): number {
    let allDownCheckpointsMet = true;
    let allUpCheckpointsMet = true;

    // Check each checkpoint for the current phase
    this.currentCheckpoints.forEach((checkpoint) => {
      const p1 = keypoints[checkpoint.keypoint1];
      const p2 = keypoints[checkpoint.keypoint2];
      const p3 = keypoints[checkpoint.keypoint3];

      if (!p1 || !p2 || !p3) {
        // Cannot calculate angle if keypoints are missing
        if (checkpoint.phase === "down") allDownCheckpointsMet = false;
        if (checkpoint.phase === "up") allUpCheckpointsMet = false;
        return;
      }

      const currentAngle = calculateAngle(p1, p2, p3);
      const isInRange =
        Math.abs(currentAngle - checkpoint.targetAngle) <= checkpoint.tolerance;

      if (checkpoint.phase === "down" && !isInRange) {
        allDownCheckpointsMet = false;
      }
      if (checkpoint.phase === "up" && !isInRange) {
        allUpCheckpointsMet = false;
      }
    });

    // Rep detection logic
    if (allDownCheckpointsMet && !this.inDownPhase) {
      this.inDownPhase = true;
      this.inUpPhase = false; // Reset up phase as we are now in down
    } else if (allUpCheckpointsMet && this.inDownPhase && !this.inUpPhase) {
      this.inUpPhase = true;
      this.repCount++;
      this.inDownPhase = false; // Reset down phase as we just completed a rep
    }

    return this.repCount;
  }
}
