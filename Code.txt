/Users/melodylo/Desktop/Computer/fitness-tracker-ai/frontend/src/components/WorkoutPage.tsx
import React, {
  useRef,
  useEffect,
  useState,
  useCallback,
  useMemo,
} from "react";
import { useParams } from "react-router-dom";
import { drawConnectors, drawLandmarks } from "@mediapipe/drawing_utils";
import { Pose, POSE_CONNECTIONS, Results } from "@mediapipe/pose";
import {
  Landmark,
  calculateAngle,
  RepCounter,
  Exercise,
} from "../utils/poseUtils";
import api from "../utils/api";

// Import new components
import CountdownOverlay from "./CountdownOverlay";
import CameraPlaceholder from "./CameraPlaceholder";
import WorkoutReport from "./WorkoutReport";
import TimerOverlay from "./TimerOverlay";
import ExerciseInfoOverlay from "./ExerciseInfoOverlay";

// Import the CSS file
import "../WorkoutPage.css";

interface WorkoutReportData {
  exerciseName: string;
  duration: number;
  totalReps: number;
  accuracy: number;
  completedAt: Date;
}

const WorkoutPage: React.FC = () => {
  const { id: exerciseId } = useParams<{ id: string }>();
  const videoElementRef = useRef<HTMLVideoElement>(null);
  const canvasElementRef = useRef<HTMLCanvasElement>(null);
  const contextRef = useRef<CanvasRenderingContext2D | null>(null);

  const [isVideoElementReady, setIsVideoElementReady] = useState(false);
  const [isCanvasElementReady, setIsCanvasElementReady] = useState(false);

  const repCounterRef = useRef<RepCounter | null>(null);
  const currentRepsRef = useRef(0);
  const [exercise, setExercise] = useState<Exercise | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [cameraError, setCameraError] = useState<string | null>(null);

  // New state variables for workout flow and UI
  const [workoutPhase, setWorkoutPhase] = useState<
    "idle" |
    "countdown" | "active" | "completed"
  >("idle");
  const [showCountdown, setShowCountdown] = useState(false);
  const [countdownValue, setCountdownValue] = useState(3);
  const [cameraActive, setCameraActive] = useState(false);
  const [showPlaceholder, setShowPlaceholder] = useState(true);
  const [showReport, setShowReport] = useState(false);
  const [workoutReport, setWorkoutReport] = useState<WorkoutReportData | null>(
    null
  );

  const [isWorkoutRunning, setIsWorkoutRunning] = useState(false);

  const [countdownWorkoutTime, setCountdownWorkoutTime] = useState(60); // State for 60-second countdown
  const [workoutDuration, setWorkoutDuration] = useState(0);
  const [displayReps, setDisplayReps] = useState(0);
  const [displayFeedback, setDisplayFeedback] = useState(
    "Stand still to begin."
  );

  const landmarkNameToIndex = useMemo(() => {
    const map: { [key: string]: number } = {
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
    };
    return map;
  }, []);

  // --- onResults Callback ---
  const onResults = useCallback(
    (results: Results) => {
      // Only process results if workout is active
      if (workoutPhase !== "active" || !exercise) {
        // Clear canvas if not active but MediaPipe might still be sending frames
        const canvasCtx = contextRef.current;
        const canvas = canvasElementRef.current;
        if (canvasCtx && canvas) {
          canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        }
        return;
      }

      const canvasCtx = contextRef.current;
      const canvas = canvasElementRef.current;
      const video = videoElementRef.current;

      if (!canvasCtx || !canvas || !video || !exercise) return;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

      const imageWidth = results.image.width;
      const imageHeight = results.image.height;

      if (canvas.width !== imageWidth || canvas.height !== imageHeight) {
        canvas.width = imageWidth;
        canvas.height = imageHeight;
        console.log(`Canvas resized to match image: ${imageWidth}x${imageHeight}`);
      }
      
      // It's crucial to draw the video image onto the canvas here
      canvasCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
      if (results.poseLandmarks) {
        const mpLandmarks = results.poseLandmarks;
        const landmarksMap: { [key: string]: Landmark } = {};

        if (mpLandmarks[11])
          landmarksMap["left_shoulder"] = mpLandmarks[11] as Landmark;
        if (mpLandmarks[12])
          landmarksMap["right_shoulder"] = mpLandmarks[12] as Landmark;
        if (mpLandmarks[13])
          landmarksMap["left_elbow"] = mpLandmarks[13] as Landmark;
        if (mpLandmarks[14])
          landmarksMap["right_elbow"] = mpLandmarks[14] as Landmark;
        if (mpLandmarks[15])
          landmarksMap["left_wrist"] = mpLandmarks[15] as Landmark;
        if (mpLandmarks[16])
          landmarksMap["right_wrist"] = mpLandmarks[16] as Landmark;
        if (mpLandmarks[23])
          landmarksMap["left_hip"] = mpLandmarks[23] as Landmark;
        if (mpLandmarks[24])
          landmarksMap["right_hip"] = mpLandmarks[24] as Landmark;
        if (mpLandmarks[25])
          landmarksMap["left_knee"] = mpLandmarks[25] as Landmark;
        if (mpLandmarks[26])
          landmarksMap["right_knee"] = mpLandmarks[26] as Landmark;
        if (mpLandmarks[27])
          landmarksMap["left_ankle"] = mpLandmarks[27] as Landmark;
        if (mpLandmarks[28])
          landmarksMap["right_ankle"] = mpLandmarks[28] as Landmark;

        let overallFormCorrect = true;
        let currentFrameFeedback = "";
        const jointsToHighlightRed: number[] = [];
        const connectionsToHighlightRed: [number, number][] = [];
        // Use isWorkoutRunning state directly here
        if (repCounterRef.current && isWorkoutRunning) {
          exercise.checkpoints.forEach((checkpoint) => {
            const p1 = landmarksMap[checkpoint.keypoint1];
            const p2 = landmarksMap[checkpoint.keypoint2];
            const p3 = landmarksMap[checkpoint.keypoint3];

            if (
              !p1 ||
              !p2 ||
              !p3 ||
              (p1.visibility && p1.visibility < 0.8) ||
              (p2.visibility && p2.visibility < 0.8) ||
              (p3.visibility && p3.visibility < 0.8)
            ) {
              overallFormCorrect = false;
              if (currentFrameFeedback === "") {
                currentFrameFeedback = "Ensure full body is visible!";
              }
              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);
              return;
            }

            // Calculate the angle between the three points
            if (!p1 || !p2 || !p3) return;
            const currentAngle = calculateAngle(p1, p2, p3);
            const isInRange =
              Math.abs(currentAngle - checkpoint.targetAngle) <=
              checkpoint.tolerance;
            if (!isInRange) {
              overallFormCorrect = false;
              if (currentAngle < checkpoint.targetAngle) {
                currentFrameFeedback = `Too shallow at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              } else {
                currentFrameFeedback = `Too deep/overextended at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              }

              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (
                p1Idx !== undefined &&
                p2Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p1Idx && c[1] === p2Idx
                )
              ) {
                connectionsToHighlightRed.push([p1Idx, p2Idx]);
              }
              if (
                p2Idx !== undefined &&
                p3Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p2Idx && c[1] === p3Idx
                )
              ) {
                connectionsToHighlightRed.push([p2Idx, p3Idx]);
              }
              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);
            }
          });
          // If form is correct, update reps and feedback
          const newReps = repCounterRef.current.detectRep(landmarksMap);
          if (newReps !== currentRepsRef.current) {
            currentRepsRef.current = newReps;
            setDisplayReps(newReps);
            setDisplayFeedback("Great Rep!");
          } else if (overallFormCorrect && currentFrameFeedback === "") {
            setDisplayFeedback("Good form!");
          } else if (currentFrameFeedback !== "") {
            setDisplayFeedback(currentFrameFeedback);
          } else {
            setDisplayFeedback("Adjust your position.");
          }
        }

        // --- Drawing Logic ---
        drawConnectors(canvasCtx, mpLandmarks, POSE_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 4,
        });
        drawLandmarks(canvasCtx, mpLandmarks, {
          color: "#00FF00",
          lineWidth: 2,
        });
        connectionsToHighlightRed.forEach(([p1Idx, p2Idx]) => {
          drawConnectors(canvasCtx, mpLandmarks, [[p1Idx, p2Idx]], {
            color: "#FF0000",
            lineWidth: 4,
          });
        });
        const redLandmarksToDraw = mpLandmarks.filter((_, idx) =>
          jointsToHighlightRed.includes(idx)
        );
        if (redLandmarksToDraw.length > 0) {
          drawLandmarks(canvasCtx, redLandmarksToDraw, {
            color: "#FF0000",
            lineWidth: 2,
          });
        }
      }
      canvasCtx.restore();
    },
    [workoutPhase, exercise, landmarkNameToIndex, isWorkoutRunning]
  );

  // --- useEffect to fetch Exercise details ---
  useEffect(() => {
    const fetchExercise = async () => {
      try {
        const res = await api.get<Exercise>(`/exercises/${exerciseId}`);
        setExercise(res.data);
        repCounterRef.current = new RepCounter(res.data.checkpoints);
        setLoading(false);
      } catch (err: any) {
        console.error("Error fetching exercise:", err);
        setError(
          err.response?.data?.message || "Failed to load exercise details"
        );
        setLoading(false);
      }
    };

    if (exerciseId) {
      fetchExercise();
    } else {
      setError("No exercise ID provided.");
      setLoading(false);
    }
  }, [exerciseId]);

  // --- Unified useEffect for MediaPipe, Camera Setup, and Canvas Context ---
  useEffect(() => {
    console.log("Unified MediaPipe & Camera Setup useEffect: Running.");

    const videoElement = videoElementRef.current;
    const canvasElement = canvasElementRef.current;
    let ctx: CanvasRenderingContext2D | null = null;

    let pose: Pose | null = null;
    let frameId: number | null = null;

    if (
      !cameraActive ||
      !isVideoElementReady ||
      !isCanvasElementReady ||
      !videoElement ||
      !canvasElement
    ) {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: Waiting for cameraActive or refs.",
        {
          cameraActive,
          isVideoElementReady,
          isCanvasElementReady,
          video: videoElement,
          canvas: canvasElement,
          context: ctx,
        }
      );
      return () => {
        console.log(
          "Unified MediaPipe & Camera Setup useEffect: No setup to clean up (refs not ready on initial mount or camera not active)."
        );
      };
    }

    console.log(
      "Unified MediaPipe & Camera Setup useEffect: All refs and state confirm mount and camera active. Proceeding with setup."
    );
    ctx = canvasElement.getContext("2d");
    if (ctx) {
      contextRef.current = ctx;
      console.log("Canvas context successfully initialized.");
    } else {
      console.error("Failed to get 2D context from canvas. Cannot proceed.");
      setError("Your browser does not support canvas 2D rendering.");
      setCameraError("Your browser does not support canvas 2D rendering.");
      return;
    }

    canvasElement.width = videoElement.videoWidth || 640;
    canvasElement.height = videoElement.videoHeight || 480;
    console.log("Canvas initial dimensions set.");

    console.log("Initializing Pose model.");
    pose = new Pose({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
      },
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      smoothSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });
    pose.onResults(onResults);
    console.log("Pose model initialized and onResults bound.");

    console.log("Attempting to get media stream and setup custom frame loop.");
    navigator.mediaDevices
      .getUserMedia({ video: { width: 1280, height: 720 } })
      .then((stream) => {
        videoElement.srcObject = stream;
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          const currentPose = pose;
          const currentVideo = videoElement;

          const sendFrameToPose = async () => {
            if (currentVideo.readyState === 4 && currentPose) {
              try {
                await currentPose.send({ image: currentVideo });
              } catch (e: any) {
                console.warn(
                  "Error sending image to pose model, likely cleanup in progress:",
                  e.message
                );
                if (e.message.includes("deleted object") && frameId !== null) {
                  cancelAnimationFrame(frameId);
                  frameId = null;
                  console.log(
                    "Stopped sending frames due to deleted pose model."
                  );
                }
              }
            }
            if (frameId !== null) {
              frameId = requestAnimationFrame(sendFrameToPose);
            }
          };
          frameId = requestAnimationFrame(sendFrameToPose);
          console.log("Camera stream started and frame loop initiated.");
        };
        console.log("getUserMedia resolved: Video stream acquired.");
      })
      .catch((err) => {
        console.error("Failed to get video stream:", err);
        let errorMessage = "Camera access failed.";
        if (err.name === "NotAllowedError") {
          errorMessage +=
            " Please allow camera permissions and refresh the page.";
        } else if (err.name === "NotFoundError") {
          errorMessage +=
            " No camera found. Please connect a camera and try again.";
        } else {
          errorMessage += " Please check your camera and try again.";
        }
        setCameraError(errorMessage);
        setError(errorMessage);
      });
    return () => {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: Cleanup running."
      );
      if (frameId !== null) {
        cancelAnimationFrame(frameId);
        frameId = null;
        console.log("Cleanup: Animation frame loop canceled.");
      }

      if (videoElement.srcObject) {
        const stream = videoElement.srcObject as MediaStream;
        stream.getTracks().forEach((track) => track.stop());
        videoElement.srcObject = null;
        console.log("Cleanup: Video stream tracks stopped.");
      }
      if (pose) {
        console.log("Cleanup: Closing Pose model.");
        pose.close();
      }

      if (ctx && canvasElement) {
        console.log("Cleanup: Clearing canvas.");
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      }
    };
  }, [onResults, isVideoElementReady, isCanvasElementReady, cameraActive]);

  const stopWorkout = useCallback(() => {
    setIsWorkoutRunning(false);
    setWorkoutPhase("completed");

    // Stop camera
    setCameraActive(false);
    // Generate report
    const report: WorkoutReportData = {
      exerciseName: exercise?.name || "Unknown",
      duration: workoutDuration,
      totalReps: displayReps,
      accuracy: 85, // Placeholder, will be calculated based on form feedback logic
      completedAt: new Date(),
    };
    setWorkoutReport(report);
    setShowReport(true);

    // Clear video stream
    const videoElement = videoElementRef.current;
    if (videoElement && videoElement.srcObject) {
      const stream = videoElement.srcObject as MediaStream;
      stream.getTracks().forEach((track) => track.stop());
      videoElement.srcObject = null;
    }
  }, [exercise, workoutDuration, displayReps, setIsWorkoutRunning, setWorkoutPhase, setCameraActive, setWorkoutReport, setShowReport]);

  const handleCountdownComplete = useCallback(() => {
    setShowCountdown(false);
    setWorkoutPhase("active");
    setIsWorkoutRunning(true);
    currentRepsRef.current = 0;
    setDisplayReps(0);
    setDisplayFeedback("Workout started! Do your first rep.");
    if (repCounterRef.current) {
      repCounterRef.current.reset();
    }
    setCountdownWorkoutTime(60); // Reset countdown for the workout itself
  }, [setIsWorkoutRunning, setWorkoutPhase, setDisplayReps, setDisplayFeedback, setCountdownWorkoutTime]);

  // FIX: Ensure handleTimeUpdate only updates if the workout is active
  const handleTimeUpdate = useCallback(
    (seconds: number) => {
      // Only update time-related states if the workout is still in the 'active' phase.
      // This prevents further updates once stopWorkout has been called and changed the phase.
      if (workoutPhase === "active") {
        setCountdownWorkoutTime(seconds);
        setWorkoutDuration(seconds);

        if (seconds <= 0) {
          stopWorkout(); // Call stopWorkout only once when time runs out
        }
      }
    },
    [workoutPhase, setWorkoutDuration, stopWorkout, setCountdownWorkoutTime]
  );

  useEffect(() => {
    let countdownInterval: number | undefined;
    if (workoutPhase === "countdown" && showCountdown) {
      countdownInterval = window.setInterval(() => {
        setCountdownValue((prev) => {
          if (prev <= 1) {
            clearInterval(countdownInterval);
            handleCountdownComplete();
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }

    return () => {
      if (countdownInterval) {
        clearInterval(countdownInterval);
      }
    };
  }, [workoutPhase, showCountdown, handleCountdownComplete]);

  const handleStartClick = () => {
    if (workoutPhase === "idle") {
      setCameraActive(true);
      setShowPlaceholder(false);
      setTimeout(() => {
        startWorkout();
      }, 500);
    }
  };

  const startWorkout = () => {
    setWorkoutPhase("countdown");
    setShowCountdown(true);
    setCountdownValue(3);
  };

  if (loading)
    return (
      <div className="container mt-5">
        <p>Loading exercise...</p>
      </div>
    );
  if (error)
    return (
      <div className="container mt-5">
        <p className="text-danger">Error: {error}</p>
      </div>
    );
  if (!exercise)
    return (
      <div className="container mt-5">
        <p>Exercise not found.</p>
      </div>
    );
  return (
    <div className="container-fluid" style={{ padding: 0 }}>
      {/* Header-only show when not in active workout */}
      {workoutPhase === "idle" && (
        <div style={{ padding: "10px", textAlign: "left" }}>
          <h1>{exercise.name}</h1>
          <p>{exercise.description}</p>
          <p>
            <strong>Target Muscles:</strong> {exercise.targetMuscles.join(", ")}
          </p>
          <p>
            <strong>Difficulty:</strong> {exercise.difficulty}
          </p>
        </div>
      )}

      {/* Control Buttons */}
      <div style={{ textAlign: "center", padding: "10px" }}>
        {workoutPhase === "idle" && (
          <button
            className="btn btn-success btn-lg"
            onClick={handleStartClick}
            style={{ minWidth: "200px" }}
          >
            Start Workout
          </button>
        )}
        {workoutPhase === "active" && (
          <button
            className="btn btn-danger btn-lg"
            onClick={stopWorkout}
            style={{ minWidth: "200px" }}
          >
            Finish Workout
          </button>
        )}
      </div>

      {/* Main Camera Area */}
      <div className="camera-container">
        {/* Camera Placeholder */}
        <CameraPlaceholder
          show={showPlaceholder}
          onStart={handleStartClick}
          exercise={exercise}
          cameraError={cameraError}
        />

        {/* Video and Canvas */}
        <video
          ref={(el) => {
            videoElementRef.current = el;
            if (el) setIsVideoElementReady(true);
            else setIsVideoElementReady(false);
          }}
          autoPlay
          playsInline
          muted
          style={{ display: cameraActive ? "block" : "none" }}
        ></video>
        <canvas
          ref={(el) => {
            canvasElementRef.current = el;
            if (el) setIsCanvasElementReady(true);
            else setIsCanvasElementReady(false);
          }}
          style={{ display: cameraActive ? "block" : "none" }}
        ></canvas>

        {/* Overlays */}
        <CountdownOverlay
          value={countdownValue}
          onComplete={handleCountdownComplete}
          show={showCountdown}
        />
        <TimerOverlay
          isRunning={isWorkoutRunning}
          seconds={countdownWorkoutTime}
          show={workoutPhase === "active"}
          onTimeUpdate={handleTimeUpdate}
          isCountdown={true}
        />
        <ExerciseInfoOverlay
          reps={displayReps}
          feedback={displayFeedback}
          show={workoutPhase === "active"}
        />
      </div>

      {/* Workout Report Modal */}
      <WorkoutReport
        report={workoutReport}
        onClose={() => {
          setShowReport(false);
          setWorkoutPhase("idle");
          setShowPlaceholder(true);
          setCameraActive(false);
          setWorkoutReport(null);
          setDisplayReps(0);
          setDisplayFeedback("Stand still to begin.");
          setWorkoutDuration(0);
          setCountdownWorkoutTime(60);
        }}
        show={showReport}
      />
    </div>
  );
};

export default WorkoutPage;
