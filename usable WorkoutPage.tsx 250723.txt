import React, {
  useRef,
  useEffect,
  useState,
  useCallback,
  useMemo,
} from "react";
import { useParams } from "react-router-dom";
import { drawConnectors, drawLandmarks } from "@mediapipe/drawing_utils";
import { Pose, POSE_CONNECTIONS, Results } from "@mediapipe/pose";
import {
  Landmark,
  calculateAngle,
  RepCounter,
  ExerciseCheckpoint,
} from "../utils/poseUtils";
import api from "../utils/api";
import WorkoutTimer from "../components/WorkoutTimer";

interface Exercise {
  _id: string;
  name: string;
  description: string;
  targetMuscles: string[];
  checkpoints: ExerciseCheckpoint[];
  instructions: string[];
  difficulty: string;
}

const WorkoutPage: React.FC = () => {
  const { id: exerciseId } = useParams<{ id: string }>();

  const videoElementRef = useRef<HTMLVideoElement>(null);
  const canvasElementRef = useRef<HTMLCanvasElement>(null);
  const contextRef = useRef<CanvasRenderingContext2D | null>(null);

  const [isVideoElementReady, setIsVideoElementReady] = useState(false);
  const [isCanvasElementReady, setIsCanvasElementReady] = useState(false);

  const repCounterRef = useRef<RepCounter | null>(null);

  const currentRepsRef = useRef(0);
  const formFeedbackRef = useRef("Stand still to begin.");

  const [exercise, setExercise] = useState<Exercise | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const isWorkoutRunningRef = useRef(false);
  const [isWorkoutRunning, setIsWorkoutRunning] = useState(false);
  useEffect(() => {
    isWorkoutRunningRef.current = isWorkoutRunning;
  }, [isWorkoutRunning]);

  const [workoutDuration, setWorkoutDuration] = useState(0);

  const [displayReps, setDisplayReps] = useState(0);
  const [displayFeedback, setDisplayFeedback] = useState(
    "Stand still to begin."
  );

  const landmarkNameToIndex = useMemo(() => {
    const map: { [key: string]: number } = {
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
    };
    return map;
  }, []);

  // --- onResults Callback ---
  const onResults = useCallback(
    (results: Results) => {
      const canvasCtx = contextRef.current;
      const canvas = canvasElementRef.current;
      const video = videoElementRef.current; // Get the current video element directly

      // Check for null refs for safety
      if (!canvasCtx || !canvas || !video || !exercise) return;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
      // It's crucial to draw the video image onto the canvas here
      canvasCtx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.poseLandmarks) {
        const mpLandmarks = results.poseLandmarks;
        const landmarksMap: { [key: string]: Landmark } = {};

        if (mpLandmarks[11])
          landmarksMap["left_shoulder"] = mpLandmarks[11] as Landmark;
        if (mpLandmarks[12])
          landmarksMap["right_shoulder"] = mpLandmarks[12] as Landmark;
        if (mpLandmarks[13])
          landmarksMap["left_elbow"] = mpLandmarks[13] as Landmark;
        if (mpLandmarks[14])
          landmarksMap["right_elbow"] = mpLandmarks[14] as Landmark;
        if (mpLandmarks[15])
          landmarksMap["left_wrist"] = mpLandmarks[15] as Landmark;
        if (mpLandmarks[16])
          landmarksMap["right_wrist"] = mpLandmarks[16] as Landmark;
        if (mpLandmarks[23])
          landmarksMap["left_hip"] = mpLandmarks[23] as Landmark;
        if (mpLandmarks[24])
          landmarksMap["right_hip"] = mpLandmarks[24] as Landmark;
        if (mpLandmarks[25])
          landmarksMap["left_knee"] = mpLandmarks[25] as Landmark;
        if (mpLandmarks[26])
          landmarksMap["right_knee"] = mpLandmarks[26] as Landmark;
        if (mpLandmarks[27])
          landmarksMap["left_ankle"] = mpLandmarks[27] as Landmark;
        if (mpLandmarks[28])
          landmarksMap["right_ankle"] = mpLandmarks[28] as Landmark;

        let overallFormCorrect = true;
        let currentFrameFeedback = "";
        const jointsToHighlightRed: number[] = [];
        const connectionsToHighlightRed: [number, number][] = [];

        if (repCounterRef.current && isWorkoutRunningRef.current) {
          exercise.checkpoints.forEach((checkpoint) => {
            const p1 = landmarksMap[checkpoint.keypoint1];
            const p2 = landmarksMap[checkpoint.keypoint2];
            const p3 = landmarksMap[checkpoint.keypoint3];

            if (
              !p1 ||
              !p2 ||
              !p3 ||
              (p1.visibility && p1.visibility < 0.8) ||
              (p2.visibility && p2.visibility < 0.8) ||
              (p3.visibility && p3.visibility < 0.8)
            ) {
              overallFormCorrect = false;
              if (currentFrameFeedback === "") {
                currentFrameFeedback = "Ensure full body is visible!";
              }
              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);

              return;
            }

            // Calculate the angle between the three points
            if (!p1 || !p2 || !p3) return; // Ensure all points are defined
            const currentAngle = calculateAngle(p1, p2, p3);
            const isInRange =
              Math.abs(currentAngle - checkpoint.targetAngle) <=
              checkpoint.tolerance;

            if (!isInRange) {
              overallFormCorrect = false;
              if (currentAngle < checkpoint.targetAngle) {
                currentFrameFeedback = `Too shallow at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              } else {
                currentFrameFeedback = `Too deep/overextended at ${
                  checkpoint.keypoint2
                }! Angle: ${currentAngle.toFixed(0)}°`;
              }

              const p1Idx = landmarkNameToIndex[checkpoint.keypoint1];
              const p2Idx = landmarkNameToIndex[checkpoint.keypoint2];
              const p3Idx = landmarkNameToIndex[checkpoint.keypoint3];

              if (
                p1Idx !== undefined &&
                p2Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p1Idx && c[1] === p2Idx
                )
              ) {
                connectionsToHighlightRed.push([p1Idx, p2Idx]);
              }
              if (
                p2Idx !== undefined &&
                p3Idx !== undefined &&
                !connectionsToHighlightRed.some(
                  (c) => c[0] === p2Idx && c[1] === p3Idx
                )
              ) {
                connectionsToHighlightRed.push([p2Idx, p3Idx]);
              }
              if (p1Idx !== undefined && !jointsToHighlightRed.includes(p1Idx))
                jointsToHighlightRed.push(p1Idx);
              if (p2Idx !== undefined && !jointsToHighlightRed.includes(p2Idx))
                jointsToHighlightRed.push(p2Idx);
              if (p3Idx !== undefined && !jointsToHighlightRed.includes(p3Idx))
                jointsToHighlightRed.push(p3Idx);
            }
          });
          // If form is correct, update reps and feedback
          const newReps = repCounterRef.current.detectRep(landmarksMap);
          if (newReps !== currentRepsRef.current) {
            currentRepsRef.current = newReps;
            setDisplayReps(newReps);
            formFeedbackRef.current = "Great Rep!";
            setDisplayFeedback("Great Rep!");
          } else if (overallFormCorrect && currentFrameFeedback === "") {
            formFeedbackRef.current = "Good form!";
            setDisplayFeedback("Good form!");
          } else if (currentFrameFeedback !== "") {
            formFeedbackRef.current = currentFrameFeedback;
            setDisplayFeedback(currentFrameFeedback);
          } else {
            formFeedbackRef.current = "Adjust your position.";
            setDisplayFeedback("Adjust your position.");
          }
        }

        // --- Drawing Logic ---
        drawConnectors(canvasCtx, mpLandmarks, POSE_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 4,
        });
        drawLandmarks(canvasCtx, mpLandmarks, {
          color: "#00FF00",
          lineWidth: 2,
        });

        connectionsToHighlightRed.forEach(([p1Idx, p2Idx]) => {
          drawConnectors(canvasCtx, mpLandmarks, [[p1Idx, p2Idx]], {
            color: "#FF0000",
            lineWidth: 4,
          });
        });

        const redLandmarksToDraw = mpLandmarks.filter((_, idx) =>
          jointsToHighlightRed.includes(idx)
        );
        if (redLandmarksToDraw.length > 0) {
          drawLandmarks(canvasCtx, redLandmarksToDraw, {
            color: "#FF0000",
            lineWidth: 2,
          });
        }
      }
      canvasCtx.restore();
    },
    [exercise, landmarkNameToIndex]
  );

  // --- useEffect to fetch Exercise details ---
  // This useEffect runs once when the component mounts to fetch exercise details
  // and sets up the RepCounter.
  // It also handles errors and loading state.
  // It does not depend on the MediaPipe or camera setup.
  useEffect(() => {
    const fetchExercise = async () => {
      try {
        const res = await api.get<Exercise>(`/exercises/${exerciseId}`);
        setExercise(res.data);
        repCounterRef.current = new RepCounter(res.data.checkpoints);
        setLoading(false);
      } catch (err: any) {
        console.error("Error fetching exercise:", err);
        setError(
          err.response?.data?.message || "Failed to load exercise details"
        );
        setLoading(false);
      }
    };

    if (exerciseId) {
      fetchExercise();
    } else {
      setError("No exercise ID provided.");
      setLoading(false);
    }
  }, [exerciseId]);

  // --- Unified useEffect for MediaPipe, Camera Setup, and Canvas Context ---
  // This useEffect will run when `isVideoElementReady` and `isCanvasElementReady` become true
  useEffect(() => {
    console.log("Unified MediaPipe & Camera Setup useEffect: Running.");

    const videoElement = videoElementRef.current;
    const canvasElement = canvasElementRef.current;
    let ctx: CanvasRenderingContext2D | null = null;

    let pose: Pose | null = null;
    let frameId: number | null = null; // To hold requestAnimationFrame ID

    if (
      isVideoElementReady &&
      isCanvasElementReady &&
      videoElement &&
      canvasElement
    ) {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: All refs and state confirm mount. Proceeding with setup."
      );

      // 1. Get Canvas Context
      ctx = canvasElement.getContext("2d");
      if (ctx) {
        contextRef.current = ctx;
        console.log("Canvas context successfully initialized.");
      } else {
        console.error("Failed to get 2D context from canvas. Cannot proceed.");
        setError("Your browser does not support canvas 2D rendering.");
        return;
      }

      // 2. Set initial canvas dimensions
      canvasElement.width = videoElement.videoWidth || 640;
      canvasElement.height = videoElement.videoHeight || 480;
      console.log("Canvas initial dimensions set.");

      // 3. Initialize Pose model
      console.log("Initializing Pose model.");
      pose = new Pose({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        },
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        smoothSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      // Crucial: onResults is a dependency of this useEffect, but its identity is stable
      pose.onResults(onResults);
      console.log("Pose model initialized and onResults bound.");

      // 4. Setup Camera (using navigator.mediaDevices for finer control)
      console.log(
        "Attempting to get media stream and setup custom frame loop."
      );
      navigator.mediaDevices
        .getUserMedia({ video: { width: 640, height: 480 } })
        .then((stream) => {
          videoElement.srcObject = stream;
          videoElement.onloadedmetadata = () => {
            videoElement.play();
            // Start sending frames after video starts playing
            // Use local 'pose' variable in sendFrameToPose
            const currentPose = pose; // Capture pose in this scope
            const currentVideo = videoElement; // Capture video in this scope

            const sendFrameToPose = async () => {
              // Only send if pose is not null and video is ready
              if (currentVideo.readyState === 4 && currentPose) {
                try {
                  await currentPose.send({ image: currentVideo });
                } catch (e: any) {
                  console.warn(
                    "Error sending image to pose model, likely cleanup in progress:",
                    e.message
                  );
                  if (
                    e.message.includes("deleted object") &&
                    frameId !== null
                  ) {
                    cancelAnimationFrame(frameId);
                    frameId = null; // Mark as stopped
                    console.log(
                      "Stopped sending frames due to deleted pose model."
                    );
                  }
                }
              }
              // Continue the loop only if it hasn't been explicitly canceled
              if (frameId !== null) {
                frameId = requestAnimationFrame(sendFrameToPose);
              }
            };
            frameId = requestAnimationFrame(sendFrameToPose);
            console.log("Camera stream started and frame loop initiated.");
          };
          console.log("getUserMedia resolved: Video stream acquired.");
        })
        .catch((err) => {
          console.error("Failed to get video stream:", err);
          setError(
            "Camera access denied or failed to start. Please allow camera permissions and ensure no other app is using it. Error: " +
              err.message
          );
        });

      // --- Cleanup ---
      return () => {
        console.log(
          "Unified MediaPipe & Camera Setup useEffect: Cleanup running."
        );

        // Stop the requestAnimationFrame loop
        if (frameId !== null) {
          cancelAnimationFrame(frameId);
          frameId = null;
          console.log("Cleanup: Animation frame loop canceled.");
        }

        // Stop video stream tracks
        if (videoElement.srcObject) {
          const stream = videoElement.srcObject as MediaStream;
          stream.getTracks().forEach((track) => track.stop());
          videoElement.srcObject = null;
          console.log("Cleanup: Video stream tracks stopped.");
        }
        // IMPORTANT: Close MediaPipe Pose model AFTER stopping camera/frames
        if (pose) {
          // Use locally scoped 'pose' for cleanup
          console.log("Cleanup: Closing Pose model.");
          pose.close();
        }
        // No need to explicitly stop MediaPipe Camera instance as we used getUserMedia directly
        // if (camera) { console.log("Cleanup: Stopping MediaPipe Camera instance."); camera.stop(); }

        if (ctx && canvasElement) {
          console.log("Cleanup: Clearing canvas.");
          ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        }
      };
    } else {
      console.log(
        "Unified MediaPipe & Camera Setup useEffect: Initial refs not available or context not ready. Waiting for mount.",
        {
          isVideoElementReady,
          isCanvasElementReady,
          video: videoElement,
          canvas: canvasElement,
          context: ctx,
        }
      );
      return () => {
        console.log(
          "Unified MediaPipe & Camera Setup useEffect: No setup to clean up (refs not ready on initial mount)."
        );
      };
    }
  }, [onResults, isVideoElementReady, isCanvasElementReady]);

  const startWorkout = () => {
    setIsWorkoutRunning(true);
    currentRepsRef.current = 0;
    setDisplayReps(0);
    formFeedbackRef.current = "Workout started! Do your first rep.";
    setDisplayFeedback("Workout started! Do your first rep.");
    if (repCounterRef.current) {
      repCounterRef.current.reset();
    }
  };

  const stopWorkout = () => {
    setIsWorkoutRunning(false);
    formFeedbackRef.current = "Workout finished!";
    setDisplayFeedback("Workout finished!");
    console.log("Workout Summary:", {
      exerciseId: exercise?.name,
      duration: workoutDuration,
      totalReps: displayReps,
    });
  };

  const handleTimeUpdate = useCallback(
    (seconds: number) => {
      setWorkoutDuration(seconds);
    },
    [setWorkoutDuration]
  );

  if (loading)
    return (
      <div className="container mt-5">
        <p>Loading exercise...</p>
      </div>
    );
  if (error)
    return (
      <div className="container mt-5">
        <p className="text-danger">Error: {error}</p>
      </div>
    );
  if (!exercise)
    return (
      <div className="container mt-5">
        <p>Exercise not found.</p>
      </div>
    );

  return (
    <div className="container mt-5">
      <h1 className="mb-4">{exercise.name}</h1>
      <p>{exercise.description}</p>
      <p>Difficulty: {exercise.difficulty}</p>

      <div className="d-flex justify-content-center my-4">
        <div
          className="camera-container"
          style={{
            position: "relative",
            width: "min(90vw, 1900px)", // Responsive width, max 1200px
            height: "min(75.8vw, 1600px)", // Maintain 4:3 aspect ratio
            maxHeight: "90vh", // Don't exceed 70% of viewport height
            margin: "0 auto",
            border: "2px solid #333",
            borderRadius: "8px",
            overflow: "hidden",
            backgroundColor: "#000",
          }}
        >
          {/* Use ref callbacks in JSX */}
          <video
            ref={(el) => {
              videoElementRef.current = el;
              if (el) setIsVideoElementReady(true);
              else setIsVideoElementReady(false);
            }}
            style={{ position: "absolute", width: "100%", height: "100%" }}
            autoPlay
            playsInline
            muted
          ></video>
          <canvas
            ref={(el) => {
              canvasElementRef.current = el;
              if (el) setIsCanvasElementReady(true);
              else setIsCanvasElementReady(false);
            }}
            style={{ position: "absolute", width: "100%", height: "100%" }}
          ></canvas>
        </div>
      </div>

      <div className="text-center my-3">
        <h3>Reps: {displayReps}</h3>
        <p className="lead">{displayFeedback}</p>
        <WorkoutTimer
          isRunning={isWorkoutRunning}
          onTimeUpdate={handleTimeUpdate}
        />
      </div>

      <div className="text-center mt-4">
        {!isWorkoutRunning ? (
          <button
            className="btn btn-success btn-lg mx-2"
            onClick={startWorkout}
          >
            Start Workout
          </button>
        ) : (
          <button className="btn btn-danger btn-lg mx-2" onClick={stopWorkout}>
            Stop Workout
          </button>
        )}
      </div>
    </div>
  );
};

export default WorkoutPage;
